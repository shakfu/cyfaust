#!/usr/bin/env python3
"""Generate the static cyfaust.pyx from the dynamic module sources.

This script consolidates the separate dynamic modules into a single
monolithic cyfaust.pyx for static linking builds.

Usage:
    python scripts/generate_static.py
"""

import re
from pathlib import Path

DYNAMIC_DIR = Path("src/cyfaust")
STATIC_DIR = Path("src/static/cyfaust")

# Order matters - dependencies must come first
MODULES = ["common", "interp", "box", "signal", "player"]

# Imports to collect at the top (deduplicated)
COLLECTED_IMPORTS = set()

# Patterns to remove (relative imports that won't work in monolithic file)
RELATIVE_IMPORT_PATTERNS = [
    r"^from \.common cimport.*$",
    r"^from \.common import.*$",
    r"^from \.box cimport.*$",
    r"^from \.box import.*$",
    r"^from \.signal cimport.*$",
    r"^from \.signal import.*$",
    r"^from \.interp cimport.*$",
    r"^from \.interp import.*$",
    r"^from \.player cimport.*$",
    r"^from \.player import.*$",
    r"^from \. cimport faust_interp as fi$",
    r"^from \. cimport faust_gui as fg$",
    r"^from \. cimport faust_box as fb$",
    r"^from \. cimport faust_signal as fs$",
    r"^from \. cimport faust_player as fp$",
]

# Standard imports to keep (will be deduplicated)
STANDARD_IMPORT_PATTERNS = [
    r"^import \w+.*$",
    r"^from lib\w+ cimport.*$",
    r"^from libcpp\.\w+ cimport.*$",
    r"^from cython\.\w+ cimport.*$",
]


def is_relative_import(line: str) -> bool:
    """Check if line is a relative import to remove."""
    for pattern in RELATIVE_IMPORT_PATTERNS:
        if re.match(pattern, line.strip()):
            return True
    return False


def is_standard_import(line: str) -> bool:
    """Check if line is a standard import to collect."""
    stripped = line.strip()
    for pattern in STANDARD_IMPORT_PATTERNS:
        if re.match(pattern, stripped):
            return True
    return False


def process_module(module_name: str) -> str:
    """Process a module file and return cleaned content."""
    pyx_file = DYNAMIC_DIR / f"{module_name}.pyx"
    if not pyx_file.exists():
        print(f"Warning: {pyx_file} not found, skipping")
        return ""

    lines = pyx_file.read_text().splitlines()
    output_lines = []

    for line in lines:
        stripped = line.strip()

        # Skip the distutils directive (we'll add one at top)
        if stripped.startswith("# distutils:"):
            continue

        # Skip relative imports
        if is_relative_import(line):
            continue

        # Collect standard imports
        if is_standard_import(line):
            COLLECTED_IMPORTS.add(stripped)
            continue

        # Uncomment cdef class member declarations (needed in monolithic file)
        # These are commented in .pyx because they're in .pxd for dynamic builds
        # Match patterns like: # cdef type name
        if stripped.startswith("# cdef ") and not stripped.startswith("# cdef void"):
            # Check if this looks like a member declaration (not a function)
            # Member declarations typically have: cdef type name or cdef public type name
            if any(kw in stripped for kw in ["argv", "argc", "ptr", "inputs", "outputs", "ptr_owner", "sound_ui"]):
                line = line.replace("# cdef ", "cdef ")

        output_lines.append(line)

    # Add module header
    header = f"\n## {'='*70}\n## Module: {module_name}\n## {'='*70}\n"
    return header + "\n".join(output_lines)


def generate_header() -> str:
    """Generate the file header with collected imports."""
    header = '''# distutils: language = c++
#
# THIS FILE IS AUTO-GENERATED - DO NOT EDIT DIRECTLY
# Generated by: scripts/generate_static.py
# Source: src/cyfaust/*.pyx
#
# NOTE: The conditional compilation block below is manually maintained
# for LLVM backend support. The LLVM_BACKEND variable is set via:
#   CMAKE_ARGS="-DLLVM=ON" (passes -E LLVM_BACKEND=True to cython)
#

import os
from libc.stdlib cimport malloc, free
from libcpp.string cimport string
from libcpp.vector cimport vector
from libcpp.map cimport map
from cython.operator cimport dereference as deref, preincrement as inc

# -----------------------------------------------------------------------------
# Backend Selection (compile-time)
# LLVM_BACKEND is defined in backend_config.pxi, generated by CMake based on -DLLVM=ON/OFF
# When LLVM_BACKEND=True, LLVM classes (LlvmDspFactory, LlvmDsp) are added.
# Interpreter classes (InterpreterDspFactory, InterpreterDsp) are always available.
# -----------------------------------------------------------------------------
include "backend_config.pxi"

# Always import interpreter backend (provides InterpreterDspFactory, InterpreterDsp)
from . cimport faust_interp as fi

from . cimport faust_box as fb
from . cimport faust_signal as fs
from . cimport faust_gui as fg
from . cimport faust_player as fp

# Define Python-visible enums (these mirror the C++ enums in faust_signal.pxd)
cpdef enum SType:
    kSInt = 0
    kSReal = 1

cpdef enum SOperator:
    kAdd = 0
    kSub = 1
    kMul = 2
    kDiv = 3
    kRem = 4
    kLsh = 5
    kARsh = 6
    kLRsh = 7
    kGT = 8
    kLT = 9
    kGE = 10
    kLE = 11
    kEQ = 12
    kNE = 13
    kAND = 14
    kOR = 15
    kXOR = 16

'''
    return header


def sync_pxd_files():
    """Sync .pxd files from dynamic to static directory."""
    print("Syncing .pxd files...")
    pxd_files = list(DYNAMIC_DIR.glob("*.pxd"))
    for pxd_file in pxd_files:
        dest = STATIC_DIR / pxd_file.name
        dest.write_text(pxd_file.read_text())
        print(f"  Copied {pxd_file.name}")
    print(f"  Synced {len(pxd_files)} .pxd files")


def generate_llvm_footer() -> str:
    """Generate the LLVM backend conditional inclusion."""
    return '''

# -----------------------------------------------------------------------------
# LLVM Backend (compile-time conditional)
# Include LLVM backend classes when built with CMAKE_ARGS="-DLLVM=ON"
# -----------------------------------------------------------------------------
IF LLVM_BACKEND:
    include "backend_llvm.pxi"
'''


def generate_static_pyx():
    """Generate the static cyfaust.pyx file."""
    print("Generating static cyfaust.pyx...")

    # Process all modules
    module_contents = []
    for module in MODULES:
        print(f"  Processing {module}.pyx...")
        content = process_module(module)
        if content:
            module_contents.append(content)

    # Generate output
    output = generate_header()
    output += "\n".join(module_contents)
    output += generate_llvm_footer()

    # Write output
    output_file = STATIC_DIR / "cyfaust.pyx"
    output_file.write_text(output)
    print(f"  Written to {output_file}")

    # Show collected imports (for debugging)
    if COLLECTED_IMPORTS:
        print(f"  Collected {len(COLLECTED_IMPORTS)} unique imports")

    # Sync .pxd files
    sync_pxd_files()


if __name__ == "__main__":
    generate_static_pyx()
